#!/usr/bin/env python
# encoding: utf-8
import argparse
import itertools
import fnmatch
import os
import re
import shutil
import sys
import tempfile

import yapgvb

from block import Block

DESCRIPTION = """\
"""

ROOT_NODE_ATTRS = dict(fontsize=12, shape="box")

GROUP_ATTRS = dict(style="filled", fillcolor="grey95", color="grey85")

# Blocks within groups
OTHER_ATTRS = dict(style="filled", fillcolor="cornsilk", color="black")

QT_ATTRS = dict(style="filled", fillcolor="darkseagreen1", color="black")

FW_ATTRS = dict(style="filled", fillcolor="azure", color="black")

# Target blocks, used with --detailed
FW_TARGET_ATTRS = dict(style="filled", fillcolor="paleturquoise")

# Highlight the wanted framework, used with --framework
WANTED_FW_ATTRS = dict(penwidth=2)

TARGET_SHAPES = [
    "polygon", # lib
    "house",   # executable
    "octagon", # module (aka plugin)
    "diamond", # static lib
    ]


DEPS_SHAPE = "ellipse"

DEPS_BLACKLIST = [
    "-l*", "-W*", # link flags
    "/*", # absolute dirs
    "m", "pthread", "util", "nsl", "resolv", # generic libs
    "*example*", "*demo*", "*test*", "*Test*", "*debug*" # helper targets
    ]

def preprocess(fname):
    lst = []
    gfx = yapgvb.Graph().read(fname)
    txt = open(fname).read()
    targets = []
    for node in gfx.nodes:
        label = node.label.replace("KF5::", "")
        if node.shape in TARGET_SHAPES:
            targets.append(label)
        txt = txt.replace('"' + node.name + '"', '"' + label + '"')

    # Sometimes cmake will generate an entry for the target alias, something
    # like this:
    #
    # "node9" [ label="KParts" shape="polygon"];
    # ...
    # "node15" [ label="KF5::KParts" shape="ellipse"];
    # ...
    #
    # After our node renaming, this ends up with a second "KParts" node
    # definition, which we need to get rid of.
    for target in targets:
        rx = r' *"' + target + '".*label="KF5::' + target + '".*shape="ellipse".*;'
        txt = re.sub(rx, '', txt)
    return txt


def to_temp_file(dirname, fname, content):
    tier = fname.split("/")[-3]
    path = os.path.join(dirname, tier + "-" + os.path.basename(fname))
    if os.path.exists(path):
        raise Exception("{} already exists".format(path))
    open(path, "w").write(content)
    return path


class Framework(object):
    def __init__(self, fname, options):
        self.options = options

        lst = os.path.basename(fname).split("-", 1)
        self.tier = lst[0]
        self.name = lst[1].replace(".dot", "")

        # A dict of target => set([targets])
        self.target_dict = {}

        src = yapgvb.Graph().read(fname)

        for node in src.nodes:
            if node.shape in TARGET_SHAPES and self.want(node):
                self.target_dict[node.name] = set()

        for edge in src.edges:
            target = edge.tail.name
            if target in self.target_dict and self.want(edge.head):
                dep_target = edge.head.name
                self.target_dict[target].add(dep_target)

    def get_all_dependencies(self):
        deps = self.target_dict.values()
        if not deps:
            return set()
        return reduce(lambda x,y: x.union(y), deps)

    def want(self, node):
        if node.shape not in TARGET_SHAPES and node.shape != DEPS_SHAPE:
            return False
        name = node.name

        for pattern in DEPS_BLACKLIST:
            if fnmatch.fnmatchcase(node.name, pattern):
                return False
        if not self.options.qt and name.startswith("Qt"):
            return False
        return True

    def __repr__(self):
        return self.name


class FrameworkCmp(object):
    def __init__(self, frameworks, fw_for_target):
        self.fw_for_target = fw_for_target
        self.src = set(frameworks)
        self.dst = []

    def __call__(self, fw1, fw2):
        if self.depends_on(fw1, fw2):
            return 1
        if self.depends_on(fw2, fw1):
            return -1
        return 0

    def depends_on(self, depender_fw, provider_fw):
        for dep_target in depender_fw.get_all_dependencies():
            if dep_target in provider_fw.target_dict:
                return True

            try:
                dep_fw = self.fw_for_target[dep_target]
            except KeyError:
                # No framework for this target, must be an external dependency,
                # carry on
                continue
            if dep_fw != depender_fw and self.depends_on(dep_fw, provider_fw):
                return True

        return False


class DotWriter(Block):
    def __init__(self, frameworks, out, wanted_fw=None, detailed=False):
        Block.__init__(self, out)
        self.frameworks = frameworks
        self.detailed = detailed
        self.wanted_fw = wanted_fw

        self.fw_for_target = {}
        for fw in self.frameworks:
            for target in fw.target_dict.keys():
                self.fw_for_target[target] = fw

    def write(self):
        with self.curly_block("digraph Root") as root:
            root.write_list_attrs("node", **ROOT_NODE_ATTRS)

            other_targets = find_external_targets(self.frameworks)
            qt_targets = set([x for x in other_targets if x.startswith("Qt")])
            other_targets.difference_update(qt_targets)

            if qt_targets:
                with root.cluster_block("Qt", **GROUP_ATTRS) as b:
                    b.write_list_attrs("node", **QT_ATTRS)
                    b.write_nodes(qt_targets)

            if other_targets:
                with root.cluster_block("Others", **GROUP_ATTRS) as b:
                    b.write_list_attrs("node", **OTHER_ATTRS)
                    b.write_nodes(other_targets)

            for tier, frameworks in itertools.groupby(self.frameworks, lambda x: x.tier):
                with root.cluster_block(tier, **GROUP_ATTRS) as tier_block:
                    tier_block.write_list_attrs("node", **FW_ATTRS)
                    # Sort frameworks within the tier to ensure frameworks which
                    # depend on other frameworks from that tier are listed after
                    # their dependees.
                    frameworks = list(frameworks)
                    for fw in sorted(frameworks, cmp=FrameworkCmp(frameworks, self.fw_for_target)):
                        if self.detailed:
                            self.write_detailed_framework(tier_block, fw)
                        else:
                            self.write_framework(tier_block, fw)

    def write_framework(self, tier_block, fw):
        if fw == self.wanted_fw:
            tier_block.write_list_attrs(fw.name, **WANTED_FW_ATTRS)
        else:
            tier_block.write_nodes([fw.name])
        edges = set([])
        for target in fw.get_all_dependencies():
            try:
                target_fw = self.fw_for_target[target]
                if fw == target_fw:
                    continue
                dep = target_fw.name
            except KeyError:
                dep = target
            edges.add((fw.name, dep))
        for edge in edges:
            tier_block.writeln('"{}" -> "{}";'.format(*edge))

    def write_detailed_framework(self, tier_block, fw):
        with tier_block.cluster_block(fw.name, **FW_ATTRS) as fw_block:
            if fw == self.wanted_fw:
                fw_block.write_attrs(**WANTED_FW_ATTRS)
            fw_block.write_list_attrs("node", **FW_TARGET_ATTRS)
            targets = sorted(fw.target_dict.keys())
            fw_block.write_nodes(targets)
            for target in targets:
                deps = fw.target_dict[target]
                for dep in sorted(deps):
                    fw_block.writeln('"{}" -> "{}";'.format(target, dep))


def find_external_targets(frameworks):
    all_targets = set([])
    fw_targets = set([])
    for fw in frameworks:
        fw_targets.update(fw.target_dict)
        all_targets.update(fw.get_all_dependencies())
    return all_targets.difference(fw_targets)


def find_framework_by_name(frameworks, name):
    for fw in frameworks:
        if fw.name == name:
            return fw
    return None


def remove_unused_frameworks(frameworks, wanted_fw):
    def is_used_in_list(the_fw, lst):
        for fw in lst:
            if fw == the_fw:
                continue
            for target in fw.get_all_dependencies():
                if target in the_fw.target_dict:
                    return True
        return False

    done = False
    old_lst = frameworks
    while not done:
        lst = []
        done = True
        for fw in old_lst:
            if fw == wanted_fw:
                lst.append(fw)
                continue
            if is_used_in_list(fw, old_lst):
                lst.append(fw)
            else:
                done = False
        old_lst = lst
    return lst


def main():
    parser = argparse.ArgumentParser(description=DESCRIPTION)

    parser.add_argument("-o", "--output", dest="output", default="-",
        help="Output to FILE", metavar="FILE")

    parser.add_argument("--qt", dest="qt", action="store_true",
        help="Show Qt libraries")

    parser.add_argument("--detailed", dest="detailed", action="store_true",
        help="Show targets within frameworks")

    parser.add_argument("--framework", dest="framework",
        help="Only show dependencies of framework FRAMEWORK", metavar="FRAMEWORK")

    parser.add_argument("dot_files", nargs="+")

    args = parser.parse_args()

    tmpdir = tempfile.mkdtemp(prefix="kf5dot")
    try:
        input_files = [to_temp_file(tmpdir, x, preprocess(x)) for x in args.dot_files]
        frameworks = [Framework(x, args) for x in input_files]
    finally:
        shutil.rmtree(tmpdir)

    if args.output == "-":
        out = sys.stdout
    else:
        out = open(args.output, "w")

    if args.framework:
        wanted_fw = find_framework_by_name(frameworks, args.framework)
        if wanted_fw is None:
            sys.stderr.write("No framework named {}.\n".format(args.framework))
            return 1
        frameworks = remove_unused_frameworks(frameworks, wanted_fw)
    else:
        wanted_fw = None

    writer = DotWriter(frameworks, out, wanted_fw=wanted_fw, detailed=args.detailed)
    writer.write()

    return 0


if __name__ == "__main__":
    sys.exit(main())
# vi: ts=4 sw=4 et
